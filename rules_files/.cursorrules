# TravelMail Project Rules

This project follows general Elixir best practices and incorporates principles from the PocketFlex Agentic Coding guide.

## Agentic Coding Philosophy

- **Agentic Collaboration**: Development involves Human Design and AI Implementation.
    - Humans: Define requirements, high-level flow/logic.
    - AI: Refines details, implements nodes/utilities, optimizes, ensures reliability.
- **Start Simple**: Begin with the simplest viable solution and iterate.
- **Design First**: Outline high-level flow/logic (e.g., in `docs/design.md` or similar) before deep implementation.
- **Seek Feedback**: Frequently ask humans for clarification and review.

## Architecture (PocketFlex Inspired)

- **Flow-Based**: Structure application logic as a flow of computation nodes.
    - Use a framework like PocketFlex if available, or model the pattern explicitly.
- **Nodes**: Implement core logic units as modules (e.g., `TravelMail.Nodes.ParseEmailNode`).
    - Follow a consistent node structure (e.g., `prep/1`, `exec/1`, `post/3`).
    - `prep`: Extracts needed data from state.
    - `exec`: Performs the core, single-responsibility task (idempotent if possible). Calls utilities for external actions.
    - `post`: Updates state based on `exec` result, determines next step using atom transitions (e.g., `:default`, `:error`, `:needs_summary`).
- **Shared State**: Use an immutable map (`shared_state`) passed between nodes for communication.
    - Keep state serializable and minimized.
    - Use structured, descriptive keys.
    - For large data, store externally and pass references in state.
- **Utilities**: Implement external interactions (database, APIs, LLM calls) in separate utility modules (e.g., `TravelMail.Utils.EmailClient`, `TravelMail.Utils.LLMCaller`).
    - Nodes call these utilities from their `exec/1` function.
- **Control Flow**: Define flow transitions explicitly (e.g., in a dedicated `TravelMail.Flow` module).
    - Use atoms for transition keys.
    - Define clear paths for success, different conditions, and errors.
- **Modularity**: Keep nodes focused on a single responsibility.

## LLM Integration

- **Wrapper Utility**: Use a dedicated utility module (e.g., `TravelMail.Utils.LLMCaller`) for all direct LLM interactions.
- **LangchainEx**: Implement the LLM utility using LangchainEx (e.g., `LLMChain`) to allow flexibility in LLM providers and leverage its features (prompt templates, history management).
- **Prompt Engineering**: Carefully design prompts within nodes that call the LLM utility. Include context, desired output format, and clear instructions.
- **Parsing**: Reliably parse LLM outputs in the calling node's `post/3` function.

## Build and Test

- Use `mix` as the build system (`mix compile`, `mix test`).
- Ensure code compiles without warnings.
- Write ExUnit tests for all nodes and utility modules.
    - Test nodes with various input states and expected transitions.
    - Use `Mox` for mocking utilities (especially `LLMCaller`, API clients) in node tests.
- Use property-based testing (`StreamData`) for complex data transformations.

## Code Style and Structure

- Format code with `mix format`.
- Run `mix credo` and address suggestions.
- Use standard Elixir file structure (`lib/travel_mail/`, `lib/travel_mail/nodes/`, `lib/travel_mail/utils/`, etc.).
- Prefer pattern matching over conditionals.
- Use `|>` for multi-step transformations.
- Use `with` for sequential operations that might fail.
- Keep functions focused; prefer smaller modules (e.g., < 300 lines).
- Place private functions below public functions.

## Error Handling

- Use `{:ok, result}` / `{:error, reason}` tuples consistently.
- Nodes should handle `{:error, reason}` from `exec/1` in their `post/3` function, update state appropriately, and return a specific transition atom (e.g., `:error`).
- The flow definition must include transitions for these error atoms.
- Use `Logger` for meaningful error messages with context.
- Avoid `try/rescue` for control flow.

## Logging and Debugging

- Use `Logger` exclusively (`require Logger`). Avoid `IO.inspect` in committed code.
- Log key events within nodes (`prep`, `exec`, `post` entry/exit, state changes, errors).
- Use appropriate log levels (`:debug`, `:info`, `:warn`, `:error`).
- Include context in logs (e.g., flow ID, node name, relevant state keys).

## Dependencies

- Use `Req` for external HTTP APIs.
- Use `LangchainEx` for LLM interactions.
- Add dependencies with `">="` in `mix.exs`.
- Document the purpose of dependencies.

## Concurrency

- Use `Task` (`Task.async`, `Task.async_stream`) for concurrent operations where appropriate (e.g., within a MapReduce-style node).
- Consider `GenServer` for stateful processes if needed (e.g., managing agent state in multi-agent systems).
- Use Supervisors for fault tolerance.

## Security

- Use environment variables for API keys and sensitive configuration.
- Validate external inputs (e.g., email content, API responses).
- Follow standard security practices for external communication and data handling.

---
# START: Content from pocket_flex/rules_files/.windsurfrules
---
layout: default
title: "Agentic Coding with PocketFlex"
---

# Agentic Coding: Humans Design, Agents Code with PocketFlex!

> If you are an AI agent involved in building LLM Systems with Elixir and PocketFlex, read this guide **VERY, VERY** carefully! This is the most important chapter in the entire document. Throughout development, you should always (1) start with a small and simple solution, (2) design at a high level (see `docs/design.md`) before implementation, and (3) frequently ask humans for feedback and clarification.
{: .warning }

This guide outlines the high-level steps for building applications with PocketFlex. For more detailed documentation on core concepts, design patterns, and tutorials, please refer to the `docs/` subdirectory within this `rules_files` directory (starting with `docs/index.md`).

## Agentic Coding Steps

Agentic Coding with PocketFlex should be a collaboration between Human System Design and Agent Implementation:

| Steps                  | Human      | AI        | Comment                                                                 |
|:-----------------------|:----------:|:---------:|:------------------------------------------------------------------------|
| 1. Requirements | ★★★ High  | ★☆☆ Low   | Humans understand the requirements and context.                    |
| 2. Flow Design     | ★★☆ Medium | ★★☆ Medium | Humans specify the high-level design ([Nodes](./docs/core_abstraction/node.md), connections/[Control Flow](./docs/core_abstraction/control_flow.md)), AI helps refine details using PocketFlex concepts. |
| 3. Utilities       | ★★☆ Medium | ★★☆ Medium | Humans provide external APIs/logic, AI helps implement them as Elixir modules/functions, potentially using LangchainEx for LLM calls. |
| 4. Node Design     | ★☆☆ Low   | ★★★ High  | The AI helps design node modules (implementing PocketFlex behaviours, see [Node](./docs/core_abstraction/node.md)) and data handling ([Shared State](./docs/core_abstraction/communication.md)). |
| 5. Implementation  | ★☆☆ Low   | ★★★ High  | The AI implements the flow and nodes using Elixir and PocketFlex based on the design. |
| 6. Optimization    | ★★☆ Medium | ★★☆ Medium | Humans evaluate results, AI helps optimize Elixir code, PocketFlex configuration, and potentially LLM prompts/models via LangchainEx. |
| 7. Reliability     | ★☆☆ Low   | ★★★ High  | The AI writes ExUnit tests, addresses corner cases using Elixir patterns, and ensures proper logging/error handling. |

1.  **Requirements**: Clarify project requirements, evaluate if PocketFlex is suitable.
    *   Understand AI system strengths/limitations.
    *   **Keep It User-Centric.**
    *   **Balance complexity vs. impact.**

2.  **Flow Design**: Outline the high-level orchestration of PocketFlex nodes.
    *   Identify patterns (e.g., [MapReduce](./docs/design_pattern/mapreduce.md), [Agent](./docs/design_pattern/agent.md), [RAG](./docs/design_pattern/rag.md), [Workflow](./docs/design_pattern/workflow.md)). See the `docs/design_pattern/` directory for details.
    *   Describe each node's purpose concisely. (See [Node](./docs/core_abstraction/node.md))
    *   Draw the flow (e.g., using Mermaid).
    *   Example Flow Diagram:
      ```mermaid
      graph TD
          A[Start: Get User Query] --> B{Node: Format Query};
          B --> C{Node: Retrieve Docs};
          C --> D{Node: Synthesize Answer (LLM)};
          D --> E[End: Present Answer];
          B --> E; # Alternative path on error/simple query?
      ```
    *   > **If Humans can't specify the flow, AI Agents can't automate it!**
      {: .best-practice }

3.  **Utilities**: Implement necessary external interactions as Elixir modules.
    *   PocketFlex nodes call these utility modules.
    *   Reading inputs (e.g., `File.read!/1`, `Req.get/1` for APIs).
    *   Writing outputs (e.g., Ecto DB interactions, `Req.post/2`).
    *   External Tools/LLMs: Implement wrappers. **Use LangchainEx specifically for LLM calls.**
    *   Implement utilities first, test with `mix test`.
    *   Document with `@moduledoc`, `@doc`, `@spec`.
    *   **Example LLM Utility using LangchainEx:**

      See: `examples/llm_caller.ex`

    *   Example Non-LLM Utility (e.g., Web Search):

      See: `examples/web_search.ex`

    *   > **Sometimes, design Utilities before Flow.**
      {: .best-practice }

4.  **Node Design**: Plan PocketFlex nodes (Elixir modules implementing `PocketFlex.Node` behaviour - *assuming this exists*).
   *   Define the `shared_state` structure (Elixir Map). (See [Communication](./docs/core_abstraction/communication.md))

     Example: See `examples/initial_state.ex`

   *   For each Node module (See [Node](./docs/core_abstraction/node.md)):
     *   Define `prep/1`: Extracts data from `shared_state`. Returns `{:ok, prep_data}`.
     *   Define `exec/1`: Performs logic using `prep_data`, calls Utilities. Returns `{:ok, exec_result}` or `{:error, reason}`.
     *   Define `post/3`: Updates `shared_state` based on `exec_result`. Returns `{:ok, {:next_action, updated_state}}` (e.g., `{:default, state}`, `{:error, state}`). Use atoms for actions.

5.  **Implementation**: Implement PocketFlex nodes and flow definitions.
   *   🎉 Agentic Coding with Elixir and PocketFlex begins!
   *   Implement node modules (`MyProject.Nodes.*`). Example: `examples/synthesize_node.ex`
   *   Implement flow definition (`MyProject.Flow.define_my_flow/0`). Example: `examples/flow_definition.ex`
   *   **Keep it simple.** Use pattern matching, `with` statements.
   *   **FAIL FAST.** Handle errors explicitly with `:ok`/`:error` tuples.
   *   Add `Logger` calls (`require Logger`).
   *   Follow project coding standards (`mix format`, `mix credo`).

7.  **Optimization**:
   *   **Use Intuition/Manual Eval.**
   *   **Redesign Flow**: Adjust node sequence, add/remove nodes, change transition logic. (See [Control Flow](./docs/core_abstraction/control_flow.md))
   *   **Micro-optimizations**:
     *   **Prompt Engineering**: Refine prompts passed to the `LLMCaller` utility.
     *   **Model Selection**: Adjust `llm_config` passed to `LLMCaller` to use different models via LangchainEx.
     *   **Node Logic**: Optimize Elixir code within `exec/1` functions.
     *   **Concurrency**: Use `Task.async` within nodes if appropriate, or use PocketFlex async node types if available. (See [MapReduce Pattern](./docs/design_pattern/mapreduce.md))

   *   > **Iteration is key!** Use `mix test` and `mix credo` regularly.
     {: .best-practice }

8.  **Reliability**
   *   **Node Retries**: Implement retry logic within `exec/1` or use a PocketFlex built-in mechanism if available.
   *   **Error Handling**: Ensure `post/3` handles `{:error, reason}` from `exec/1` appropriately (e.g., logs error, sets error state, transitions to an error handling node). Define clear error paths in the flow definition.
   *   **Logging**: Use `Logger` with context (e.g., flow ID, node name) in `prep`, `exec`, and `post`.
   *   **Testing**: Write comprehensive ExUnit tests for each node. Use `Mox` to mock Utilities (like `LLMCaller` and `WebSearch`). Test flows with different initial states and expected transitions.
   *   **Self-Evaluation**: Implement a specific PocketFlex node that uses `LLMCaller` (via LangchainEx) to review the output of previous nodes.

## Example PocketFlex Project File Structure (Elixir)


- **`lib/my_project/utils/llm_caller.ex`**: Contains the LangchainEx wrapper.

  See: `examples/llm_caller.ex`

- **`lib/my_project/nodes/synthesize_node.ex`**: Example node calling the LLM utility.

  See: `examples/synthesize_node.ex`

- **`lib/my_project/flow.ex`**: Defines the flow connecting these nodes (example assuming PocketFlex API).

  See: `examples/flow_definition.ex`

- **Entry Point (`mix run ...` or main function)**: Sets up initial state, gets flow definition, calls `PocketFlex.run/2`.

---

**Further Reading:**

- For detailed explanations of core concepts, see the files in `docs/core_abstraction/`.
- For implementations of common patterns, see `docs/design_pattern/`.
- For step-by-step examples, see the tutorials in `docs/tutorials/`.

Remember to adapt PocketFlex API calls based on its actual implementation. Consult LangchainEx docs for LLM configuration and response handling. Follow all project rules (`.cursorrules`). Format code using `mix format`. Check with `mix credo`.

---
# START: Content from pocket_flex/rules_files/.cursorrules
---
# Rules for working within the `rules_files` directory

This file provides specific guidance when editing the PocketFlex framework documentation and examples contained within this `rules_files` directory. These rules supplement the general project rules found in the root `.cursorrules` file.

## General Structure

- **`.windsurfrules`**: This is the main high-level guide ("Agentic Coding with PocketFlex"). It introduces concepts and references detailed documentation and examples.
- **`docs/`**: Contains detailed documentation files (Markdown format) covering Core Abstractions, Design Patterns, and Tutorials.
- **`examples/`**: Contains standalone Elixir code snippets (`.ex` files) referenced from the `.windsurfrules` guide and potentially the `docs/` files.

## Content and Consistency

- **Framework Context**: All documentation and examples should primarily describe and use the **PocketFlex** framework concepts (Nodes, Flows, Shared State, etc.).
- **LLM Interaction Exception**: When showing code examples that *directly invoke an LLM*, use the **LangchainEx** library (as demonstrated in `examples/llm_caller.ex`). This provides flexibility in the LLM backend. Nodes *using* the LLM should call this utility wrapper.
- **Consistency**: Ensure consistency between the `.windsurfrules` guide, the detailed documentation in `docs/`, and the code in `examples/`. If a concept is updated in one place, check if related explanations or examples in other files need updating.
- **Linking**:
    - Within `.windsurfrules`, use relative links (e.g., `[Node](./docs/core_abstraction/node.md)`, `[Example](examples/llm_caller.ex)`) to point to detailed docs or examples.
    - Within files in `docs/`, use relative links to refer to other docs (e.g., `[Node](../core_abstraction/node.md)`) or examples (e.g., `[LLM Caller Example](../../examples/llm_caller.ex)`).

## Guide (`.windsurfrules`)

- Keep this file as a high-level overview and guide to the Agentic Coding process with PocketFlex.
- Avoid putting very long code blocks or extremely detailed explanations here; instead, reference the appropriate files in `docs/` or `examples/`.
- Ensure the Agentic Coding steps and overall narrative remain clear and focused.

## Documentation (`docs/`)

- Use clear and concise language.
- Use standard Markdown formatting.
- Organize files logically within subdirectories (`core_abstraction`, `design_pattern`, `tutorials`).
- Use code blocks (` ```elixir ... ``` `) for short Elixir examples where appropriate, but prefer referencing larger examples in the `examples/` directory if the snippet becomes too long.
- Explain PocketFlex concepts clearly, referencing Elixir/OTP principles where relevant.

## Examples (`examples/`)

- Each `.ex` file should represent a focused, runnable (or near-runnable, perhaps requiring minor setup) code snippet illustrating a specific concept.
- Follow the general Elixir coding standards defined in the root `.cursorrules` (formatting with `mix format`, logging with `Logger`, error handling with tuples, etc.).
- Use comments (`#`) to explain the code and its relation to PocketFlex concepts.
- Keep examples minimal and directly relevant to the point being illustrated in the guide or docs.
- Ensure the `llm_caller.ex` example correctly uses `LangchainEx` patterns.

---
# START: Content from pocket_flex/rules_files/docs/index.md
---
layout: default
title: "Home"
nav_order: 1
---

# PocketFlex

A minimalist Elixir framework inspired by PocketFlow for *Agents, Task Decomposition, RAG, etc.*.

- **Lightweight**: Focuses on the core flow graph abstraction.
- **Expressive**: Aims to enable patterns like Agents, Workflows, RAG, etc., using Elixir idioms.
- **Agentic-Coding Friendly**: Designed to be intuitive for AI agents collaborating with humans to build complex LLM applications in Elixir.

<div align="center">
  <img src="https://github.com/the-pocket/PocketFlow/raw/main/assets/meme.jpg?raw=true" width="400"/>
  <!-- TODO: Replace with a PocketFlex specific meme/logo -->
</div>

## Core Abstraction

PocketFlex orchestrates computations through a directed graph of **Nodes**. Each node performs a specific task, potentially interacting with external **Utilities** (including LLMs via wrappers like LangchainEx) and communicating through a shared **State** map.

- **[Node](./core_abstraction/node.md)**: The basic unit of computation, likely implemented as an Elixir module following a specific behaviour.
- **[Communication](./core_abstraction/communication.md)**: How nodes share data, typically via an immutable shared state map passed through the flow.
- **[Control Flow](./core_abstraction/control_flow.md)**: How the execution path is determined, usually based on the return values of a node's `post/3` function.

## Design Patterns

Explore common patterns implemented with PocketFlex:

- **[Agent](./design_pattern/agent.md)**: Nodes making decisions based on state and LLM outputs.
- **[RAG (Retrieval-Augmented Generation)](./design_pattern/rag.md)**: Combining retrieval nodes and LLM synthesis nodes.
- **[MapReduce](./design_pattern/mapreduce.md)**: Using Elixir's concurrency (`Task.async_stream`) potentially orchestrated by PocketFlex nodes.
- **[Workflow](./design_pattern/workflow.md)**: Defining complex sequences and conditional paths.
- **[Multi-Agent](./design_pattern/multi_agent.md)**: Coordinating multiple independent PocketFlex flows or agents (potentially using OTP principles).

## Tutorials

Get started with these examples:

- **[Hello World](./tutorials/hello_world.md)**: A minimal PocketFlex flow.
- **[Chatbot](./tutorials/chatbot.md)**: Building a conversational agent.
- **[Code Generation](./tutorials/code_generation.md)**: Using PocketFlex and an LLM for code tasks.
- **[Web Search](./tutorials/web_search.md)**: Integrating external tools like web search.

---
# START: Content from pocket_flex/rules_files/docs/core_abstraction/node.md
---
layout: default
title: "Node"
parent: "Core Abstraction"
nav_order: 1
---

# Node

The fundamental unit of computation in PocketFlex. Each Node encapsulates a specific piece of logic within the overall flow.

## Node Behaviour (Conceptual)

While the exact implementation might vary, a PocketFlex Node is conceptually an Elixir module implementing a specific behaviour (e.g., `PocketFlex.Node`). This behaviour likely defines callback functions:

- `prep/1`:
  - **Input**: The current `shared_state` (Map).
  - **Output**: `{:ok, prep_data}` or `{:error, reason}`.
  - **Purpose**: Extracts necessary data from the shared state for the `exec` step. Avoids complex computation.
- `exec/1`:
  - **Input**: `{:ok, prep_data}` from `prep/1`.
  - **Output**: `{:ok, exec_result}` or `{:error, reason}`.
  - **Purpose**: Performs the core logic of the node. This is where computations happen, utilities are called (including LLMs via wrappers), etc. Should be idempotent if possible.
- `post/3`:
  - **Input**: Original `shared_state`, `prep_data` (from `prep/1`), `exec_result` (from `exec/1`, which could be `{:ok, _}` or `{:error, _}`).
  - **Output**: `{:ok, {next_action_atom, updated_state}}` or potentially `{:error, reason}` for critical post-processing errors.
  - **Purpose**: Updates the `shared_state` based on the execution result and determines the next step in the flow via the `next_action_atom` (e.g., `:default`, `:success`, `:error`, `:custom_path`). Must handle both success and error cases from `exec/1`.

## Example Node

```elixir
# Example Node: lib/my_project/nodes/add_value_node.ex
# (Assumes a PocketFlex.Node behaviour exists)
defmodule MyProject.Nodes.AddValueNode do
  @moduledoc "A simple node that adds a value from config to the state."
  # @behaviour PocketFlex.Node
  require Logger

  # 1. Prepare: Get the value to add (e.g., from config or initial state)
  def prep(shared_state) do
    # Example: Get value from application config or a default
    value_to_add = Application.get_env(:my_app, :value_to_add, 10)
    current_total = Map.get(shared_state, :total, 0)
    Logger.debug("Prep AddValueNode: Current total=#{current_total}, Value to add=#{value_to_add}")
    {:ok, %{current_total: current_total, value_to_add: value_to_add}}
  end

  # 2. Execute: Perform the addition
  def exec({:ok, %{current_total: total, value_to_add: value}}) do
    new_total = total + value
    Logger.debug("Exec AddValueNode: New total=#{new_total}")
    {:ok, new_total}
  end
  def exec({:error, reason}) do
     # Propagate prep error
     Logger.error("AddValueNode skipped due to prep error: #{inspect(reason)}")
    {:error, reason}
  end

  # 3. Post-process: Update the shared state and determine next step
  def post(shared_state, _prep_data, {:ok, new_total}) do
    updated_state = Map.put(shared_state, :total, new_total)
    Logger.debug("Post AddValueNode: Updated state: #{inspect(updated_state)}")
    # Transition to the default next node
    {:ok, {:default, updated_state}}
  end
  def post(shared_state, _prep_data, {:error, reason}) do
     # If exec failed, log it and maybe transition differently
     Logger.error("AddValueNode failed in exec: #{inspect(reason)}")
     updated_state = Map.put(shared_state, :error_info, {__MODULE__, :exec_failed, reason})
     # Transition via an :error path
     {:ok, {:error, updated_state}}
  end
end
```

## Node Types

PocketFlex might define different node types or allow customization:

- **Regular Node**: Executes sequentially.
- **Async Node**: Executes potentially in a separate process (`Task.async`?).
- **Batch Node**: Processes multiple items (perhaps using `Task.async_stream`).
- **Router Node**: Primarily determines control flow based on state, with minimal `exec` logic.
- **Agent Node**: Uses an LLM in `exec` to decide the `next_action_atom` in `post`.

Refer to the specific PocketFlex implementation for available node types and behaviours.

---
# START: Content from pocket_flex/rules_files/docs/core_abstraction/communication.md
---
layout: default
title: "Communication (Shared State)"
parent: "Core Abstraction"
nav_order: 2
---

# Communication: Shared State

PocketFlex nodes communicate and share data primarily through an immutable **Shared State** map. This map is passed from node to node throughout the execution of a flow.

## Concept

- **Immutable Map**: The shared state is typically an Elixir map (`%{:key => value}`). Because Elixir data structures are immutable, each node receives the state map, and the `post/3` function returns a *new*, updated state map. This prevents side effects and makes flows easier to reason about.
- **Centralized Data**: All data required by downstream nodes or produced by upstream nodes resides in this shared state map.
- **Node Responsibility**:
    - The `prep/1` function reads necessary data *from* the state.
    - The `post/3` function writes results *to* a new version of the state map.

## Example

```elixir
# Initial state provided to the flow
initial_state = %{
  user_id: "user123",
  input_text: "Some text to process.",
  results: %{},
  config: %{mode: :fast}
}

# --- Node A runs ---
# Prep reads :input_text
# Exec processes the text
# Post updates the state
state_after_node_a = %{
  user_id: "user123",
  input_text: "Some text to process.",
  results: %{
    processed_text: "SOME TEXT TO PROCESS."
  },
  config: %{mode: :fast}
}

# --- Node B runs ---
# Prep reads results.processed_text
# Exec analyzes the processed text
# Post updates the state
state_after_node_b = %{
  user_id: "user123",
  input_text: "Some text to process.",
  results: %{
    processed_text: "SOME TEXT TO PROCESS.",
    analysis: %{word_count: 4, sentiment: :neutral}
  },
  config: %{mode: :fast}
}

# And so on...
```

## Best Practices

- **Keep it Serializable**: If you need to persist the state or pass it between processes, ensure the values in the map are easily serializable (basic Elixir types, simple structs). Avoid storing PIDs, function references, or complex ETS tables directly in the state if persistence or distribution is needed.
- **Structured Keys**: Use descriptive atoms or nested maps for keys to keep the state organized (e.g., `%{results: %{analysis: ...}}` instead of `%{analysis_result: ...}`).
- **Minimize State**: Only store data in the shared state that is truly needed by subsequent nodes. Avoid cluttering it with temporary data used only within a single node.
- **Consider Alternatives for Large Data**: For very large data (e.g., large files, embeddings), consider storing them outside the main state map (e.g., in ETS, a database, or cloud storage) and passing only references (IDs, paths) in the state map.

---
# START: Content from pocket_flex/rules_files/docs/core_abstraction/control_flow.md
---
layout: default
title: "Control Flow"
parent: "Core Abstraction"
nav_order: 3
---

# Control Flow

PocketFlex manages the sequence of execution between [Nodes](./node.md) based on the flow definition and the runtime results returned by each node's `post/3` callback.

## Transition Logic

- **Flow Definition**: The overall structure (which nodes connect to which) is typically defined when the flow is created. This definition maps `next_action_atom` results from a source node to a destination node (or a special `:end` state).
- **`post/3` Return Value**: The `post/3` function of a node determines the *immediate next step* by returning `{:ok, {next_action_atom, updated_state}}`.
- **`next_action_atom`**: This atom (e.g., `:default`, `:success`, `:error`, `:user_input_required`, `:condition_met`) dictates which transition path to take from the current node.

## Example Flow Definition (Conceptual)

```elixir
# Hypothetical flow definition using PocketFlex API
PocketFlex.define(
  start_node: MyProject.Nodes.StartNode,
  nodes: [
    # StartNode transitions
    %{module: MyProject.Nodes.StartNode,
      transitions: %{
        default: MyProject.Nodes.ProcessDataNode, # Default path
        needs_auth: MyProject.Nodes.AuthNode      # Conditional path
      }
    },

    # ProcessDataNode transitions
    %{module: MyProject.Nodes.ProcessDataNode,
      transitions: %{
        default: MyProject.Nodes.EndNode,       # Successful processing
        error: MyProject.Nodes.ErrorHandlingNode # Error during processing
      }
    },

    # AuthNode transitions
    %{module: MyProject.Nodes.AuthNode,
      transitions: %{
        success: MyProject.Nodes.ProcessDataNode, # If auth succeeds, go process
        failure: MyProject.Nodes.EndNode          # If auth fails, end
      }
    },

    # ErrorHandlingNode transitions
    %{module: MyProject.Nodes.ErrorHandlingNode,
      transitions: %{
        default: MyProject.Nodes.EndNode         # Always end after logging error
      }
    },

    # EndNode is a terminal state (no transitions out)
    %{module: MyProject.Nodes.EndNode, transitions: %{}}
  ]
)
```

## How it Works (Simplified)

1. The flow starts at the `start_node` (`StartNode` in the example).
2. `StartNode.prep/1` runs.
3. `StartNode.exec/1` runs.
4. `StartNode.post/3` runs and returns, say, `{:ok, {:default, updated_state}}`.
5. PocketFlex looks up the `:default` transition for `StartNode` in the flow definition, finding `ProcessDataNode`.
6. The `updated_state` is passed to `ProcessDataNode.prep/1`.
7. `ProcessDataNode.exec/1` runs. Let's say it returns `{:error, :db_timeout}`.
8. `ProcessDataNode.post/3` receives the error and returns `{:ok, {:error, state_with_error_info}}`.
9. PocketFlex looks up the `:error` transition for `ProcessDataNode`, finding `ErrorHandlingNode`.
10. The `state_with_error_info` is passed to `ErrorHandlingNode.prep/1`.
11. ... and so on, until a node transitions to a defined end state or has no further transitions defined.

## Key Concepts

- **Atom-Based Transitions**: Using atoms (`:default`, `:error`, etc.) for transition keys is conventional and efficient in Elixir.
- **Explicit Paths**: Define all expected transitions clearly in the flow definition.
- **Error Handling**: Design dedicated error paths or nodes, triggered by specific error atoms returned from `post/3`.

---
# START: Content from pocket_flex/rules_files/docs/design_pattern/agent.md
---
layout: default
title: "Agent"
parent: "Design Patterns"
nav_order: 1
---

# Design Pattern: Agent

An "Agent" in the context of LLM frameworks like PocketFlex typically refers to a system that uses an LLM to make decisions about what actions to take next.

## Concept in PocketFlex

Instead of a monolithic "Agent" object, an agentic pattern in PocketFlex is often implemented using a combination of:

1.  **LLM Utility**: A utility module (like the `LLMCaller` example using LangchainEx) that allows nodes to invoke an LLM.
2.  **Agentic Node(s)**: One or more PocketFlex [Nodes](../core_abstraction/node.md) whose primary purpose is to:
    *   Prepare a prompt for the LLM based on the current [Shared State](../core_abstraction/communication.md) and available tools/actions.
    *   Execute the LLM call via the utility.
    *   Post-process the LLM response to determine the next action (which might be calling another tool/utility node or deciding the next step in the [Control Flow](../core_abstraction/control_flow.md)).
3.  **Tool Nodes/Utilities**: Regular Elixir modules or specific PocketFlex nodes that perform concrete actions (e.g., web search, database query, file I/O), which the agentic node can decide to invoke (often indirectly by setting specific flags or data in the shared state that trigger a transition to the tool node).

## Example Flow

```mermaid
graph TD
    A[Start: User Query] --> B{Agent Node: Plan Next Step};
    B -- Decision: Need Search --> C{Tool Node: Web Search};
    B -- Decision: Need DB Info --> D{Tool Node: Database Query};
    B -- Decision: Answer Directly --> E{Node: Format Answer};
    C --> F{Agent Node: Process Search Results};
    D --> G{Agent Node: Process DB Results};
    F --> B; # Re-plan based on search
    G --> B; # Re-plan based on DB info
    E --> Z[End: Show Answer];
```

## Implementation Notes

- **Prompt Engineering**: The core of the agentic node lies in constructing the right prompt for the LLM. This prompt should include:
    - The overall goal.
    - The current state/context.
    - Available actions/tools (with descriptions).
    - Instructions on how the LLM should format its response (e.g., specify the next action/tool and its parameters).
- **Parsing LLM Output**: The `post/3` function of the agentic node needs to reliably parse the LLM's response to extract the chosen action and parameters.
- **State Management**: The agentic node updates the shared state with its plan or the results of tool executions.
- **Control Flow**: Transitions in the flow definition (`:need_search`, `:need_db`, `:answer_ready`) are based on the parsed LLM decision returned by the agentic node's `post/3` function using different `next_action_atom` values.
- **Tool Execution**: Often, the agent node doesn't call the tool directly in `exec/1`. Instead, its `post/3` function returns a specific atom (e.g., `:invoke_web_search`), and the flow definition routes this to the `WebSearchNode`. The `WebSearchNode` performs the action, and its `post/3` likely transitions back to the agent node with the results added to the shared state.

This modular approach allows for better testing and separation of concerns compared to a single, large agent function.

---
# START: Content from pocket_flex/rules_files/docs/design_pattern/rag.md
---
layout: default
title: "RAG (Retrieval-Augmented Generation)"
parent: "Design Patterns"
nav_order: 2
---

# Design Pattern: RAG (Retrieval-Augmented Generation)

RAG combines information retrieval with large language model (LLM) generation to produce answers grounded in external knowledge.

## Concept in PocketFlex

A RAG pipeline in PocketFlex is typically implemented as a flow with distinct [Nodes](../core_abstraction/node.md) for each stage:

1.  **Query Formulation Node (Optional)**: Takes the initial user query from the [Shared State](../core_abstraction/communication.md) and potentially reformulates it (using an LLM via a utility like `LLMCaller`) into a better query for retrieval.
2.  **Retrieval Node**:
    *   Takes the (possibly reformulated) query.
    *   Uses a utility function to search a knowledge base (e.g., a vector store like ChromaDB, Qdrant, or a traditional search index like Elasticsearch) for relevant documents/text chunks.
    *   This utility might involve generating embeddings (potentially using LangchainEx embeddings modules) and performing similarity searches.
    *   Adds the retrieved documents/chunks to the shared state.
3.  **Synthesis Node**:
    *   Takes the original query and the retrieved documents from the shared state.
    *   Constructs a prompt for an LLM, including the query and the retrieved context.
    *   Uses an LLM utility (like `LLMCaller`) to generate an answer based *only* on the provided context.
    *   Adds the final generated answer to the shared state.

## Example Flow

```mermaid
graph TD
    A[Start: User Query] --> B(Node: Retrieve Docs);
    B --> C(Node: Synthesize Answer);
    C --> D[End: Final Answer];

    subgraph "Optional Preprocessing"
        A --> A1(Node: Reformulate Query);
        A1 --> B;
    end
```

## Implementation Notes

- **Indexing (Offline Process)**: The knowledge base (e.g., vector store) needs to be populated beforehand. This involves:
    - Loading documents (using Elixir file reading, HTTP clients like `Req`, or LangchainEx `DocumentLoaders`).
    - Splitting documents into chunks (using custom logic or LangchainEx `TextSplitters`).
    - Generating embeddings for each chunk (using an embedding model via LangchainEx or another library).
    - Storing the chunks and their embeddings in the chosen vector store/index.
- **Retrieval Utility**: The `exec/1` function of the Retrieval Node calls a utility that encapsulates the logic for:
    - Generating an embedding for the input query.
    - Performing a similarity search against the vector store.
    - Returning the relevant document chunks.
- **Synthesis Node Prompt**: The prompt engineering for the Synthesis Node is crucial. It must instruct the LLM to base its answer strictly on the retrieved context provided in the prompt to avoid hallucination and ensure grounding.
- **Error Handling**: Implement error handling in the [Control Flow](../core_abstraction/control_flow.md) for cases like retrieval failure or LLM errors during synthesis.

Building RAG with PocketFlex involves composing these specialized nodes, leveraging external Elixir libraries or custom utilities for tasks like embedding generation and vector search within the node implementations.

---
# START: Content from pocket_flex/rules_files/docs/design_pattern/mapreduce.md
---
layout: default
title: "MapReduce"
parent: "Design Patterns"
nav_order: 3
---

# Design Pattern: MapReduce

The MapReduce pattern involves splitting a large task into smaller, independent sub-tasks (Map), processing them concurrently, and then combining the results (Reduce).

## Concept in PocketFlex

PocketFlex itself might not have a dedicated "MapReduce Node" type, but this pattern can be implemented using standard Elixir concurrency features orchestrated by PocketFlex nodes:

1.  **Setup Node**: Prepares the data. Reads the large dataset or list of items to be processed from the [Shared State](../core_abstraction/communication.md) or an external source.
2.  **Map Node**:
    *   Takes the list of items from the Setup Node.
    *   Uses `Task.async_stream/3` or `Task.async_stream/5` to concurrently apply a mapping function to each item. This mapping function might:
        *   Perform a simple transformation.
        *   Call an external utility (including LLMs via `LLMCaller`).
        *   Even run a sub-flow using PocketFlex (though this adds complexity).
    *   The `exec/1` function manages the `Task.async_stream` and collects all results (which could be `{:ok, result}` or `{:error, reason}` tuples).
    *   Adds the list of results (including any errors) to the shared state.
3.  **Reduce Node**:
    *   Takes the list of results from the Map Node's output in the shared state.
    *   Processes the results:
        *   Filters out or handles errors.
        *   Aggregates, summarizes, or combines the successful results into a final output.
    *   Adds the final aggregated result to the shared state.

## Example Flow

```mermaid
graph TD
    A[Start: Input Data] --> B(Node: Setup Data Split);
    B --> C{Node: Map Tasks Concurrently};
    C --> D(Node: Reduce Results);
    D --> E[End: Final Result];
    C -- Error Handling --> F(Node: Handle Task Errors);
    F --> D; # Feed error summary to Reduce?
```

## Implementation Notes

- **Concurrency with `Task.async_stream`**: The core of the Map stage is leveraging Elixir's built-in task management. The Map Node's `exec/1` function would look something like this (simplified):
    ```elixir
    def exec({:ok, %{items: items_to_process}}) do
      results =
        items_to_process
        |> Task.async_stream(&process_single_item/1, timeout: 60000, max_concurrency: 10)
        |> Enum.map(fn {:ok, result} -> result end) # Task.async_stream returns {:ok, result} tuples

      # results will be a list of {:ok, item_result} or {:error, reason} tuples
      {:ok, results}
    end

    defp process_single_item(item) do
      # Logic to process one item
      # May call utilities, LLMs, etc.
      # Must return {:ok, result} or {:error, reason}
      # Example:
      case MyUtility.process(item) do
         {:ok, processed} -> {:ok, processed}
         {:error, err} -> {:error, {item, err}} # Include original item in error
      end
    end
    ```
- **Error Handling**: The `Task.async_stream` collects results including errors. The Reduce Node must explicitly handle potential `{:error, reason}` tuples in the results list.
- **Resource Management**: Be mindful of `max_concurrency` and `timeout` options in `Task.async_stream` to avoid overwhelming system resources or external APIs.
- **State**: The large list of items might be passed via the shared state, or the Setup Node might pass references (e.g., IDs to fetch from a DB) to keep the state map smaller, with the Map Node fetching details within `process_single_item/1`.

---
# START: Content from pocket_flex/rules_files/docs/design_pattern/workflow.md
---
layout: default
title: "Workflow"
parent: "Design Patterns"
nav_order: 4
---

# Design Pattern: Workflow

A workflow represents a more complex sequence of tasks with potential branching, conditions, and loops, often orchestrating multiple simpler patterns.

## Concept in PocketFlex

A workflow in PocketFlex is simply a well-defined **Flow** composed of multiple [Nodes](../core_abstraction/node.md) connected via specific [Control Flow](../core_abstraction/control_flow.md) transitions.

Key elements for building complex workflows include:

- **Conditional Transitions**: A node's `post/3` function can return different `next_action_atom` values based on the `exec/1` result or data in the [Shared State](../core_abstraction/communication.md). The flow definition maps these atoms to different downstream nodes, creating branches.
- **Router Nodes**: Nodes whose primary purpose is to evaluate the shared state and determine the next path, often with minimal computation in `exec/1`. They return different atoms from `post/3` to direct the flow.
- **Looping**: Loops can be implemented by defining transitions that route back to an earlier node in the flow. A node within the loop must eventually return a different `next_action_atom` to break the loop, typically based on conditions met in the shared state (e.g., a counter reaching a limit, a specific result being found).
- **Sub-Flows (Conceptual)**: While PocketFlex might not have explicit sub-flow support, you can conceptually achieve this by having a node's `exec/1` function run another, separate PocketFlex flow definition using `PocketFlex.run/2`. The results of the sub-flow are then processed in the calling node's `post/3`. (This adds complexity and requires careful state management).

## Example Workflow: Simple Approval Process

```mermaid
graph TD
    A[Start: Submit Data] --> B(Node: Validate Data);
    B -- Valid --> C{Node: Request Approval};
    B -- Invalid --> D(Node: Notify User of Error);
    C -- Approved --> E(Node: Process Approved Data);
    C -- Rejected --> F(Node: Notify User of Rejection);
    D --> Z[End];
    E --> Z[End];
    F --> Z[End];
```

## Implementation Notes

- **Clear Flow Definition**: Define all nodes and their transitions explicitly when creating the flow. Visualizing it with Mermaid or similar tools is highly recommended.
- **State Design**: Carefully design the shared state map to hold all necessary information for decision-making at branch points (e.g., validation status, approval status, loop counters).
- **Node Granularity**: Break down the workflow into logical, single-responsibility nodes. Avoid putting too much complex branching logic inside a single node's `post/3` function; use dedicated router nodes or clear conditional transitions instead.
- **Error Handling**: Define clear error paths (`:error` transitions) at each stage where failures can occur.

Workflows in PocketFlex leverage the core concepts of nodes, shared state, and control flow to orchestrate complex sequences of operations.

---
# START: Content from pocket_flex/rules_files/docs/design_pattern/multi_agent.md
---
layout: default
title: "Multi-Agent"
parent: "Design Patterns"
nav_order: 5
---

# Design Pattern: Multi-Agent System

A multi-agent system involves multiple independent agents collaborating or competing to achieve a goal.

## Concept in PocketFlex

Implementing a multi-agent system in PocketFlex and Elixir involves orchestrating multiple, potentially concurrent, PocketFlex flows or agentic processes.

Several approaches are possible:

1.  **Orchestrator Flow**:
    *   A main PocketFlex flow acts as the orchestrator.
    *   Specific nodes within this flow are responsible for launching other PocketFlex flows (representing individual agents) perhaps using `Task.async` or by starting supervised `GenServer` processes that run the agent flows.
    *   The orchestrator node waits for results from the agent flows (e.g., via `Task.await`, message passing from `GenServer`s) and manages their interaction or aggregates their results.
    *   Communication between agents might happen indirectly via updates to a shared resource (like a database or ETS table) managed or monitored by the orchestrator, or via direct message passing if using stateful processes like `GenServer`s.

2.  **Independent Flows with Shared Resources**:
    *   Multiple PocketFlex flows run independently (potentially as separate OTP applications or supervised processes).
    *   They coordinate or communicate by reading from and writing to shared resources (e.g., a database, a shared ETS table, a message queue like RabbitMQ).
    *   Each flow might represent an agent with a specific role (e.g., Researcher Agent, Writer Agent, Reviewer Agent).

3.  **Agent Processes (GenServers)**:
    *   Each agent is implemented as a `GenServer` or similar OTP process.
    *   The agent's internal logic might be implemented using a PocketFlex flow, which the `GenServer` runs via `PocketFlex.run/2` in its message handlers.
    *   Agents communicate by sending messages (`GenServer.call/3`, `GenServer.cast/2`) to each other, possibly managed via Elixir's `Registry` for discovery.

## Example Flow (Orchestrator Approach)

```mermaid
graph TD
    A[Start: Main Goal] --> B{Orchestrator Node: Assign Tasks};
    B --> C(Task: Run Researcher Agent Flow);
    B --> D(Task: Run Writer Agent Flow);
    C --> E{Orchestrator Node: Collect Research};
    D --> F{Orchestrator Node: Collect Draft};
    E --> G{Orchestrator Node: Synthesize};
    F --> G;
    G --> H[End: Final Output];
```

## Implementation Notes

- **Concurrency Model**: Choose the right Elixir concurrency mechanism (`Task`, `GenServer`, `Registry`) based on the required agent lifetime, state management needs, and communication patterns.
- **Communication**: Define clear communication protocols between agents, whether via shared state, message passing, or shared external resources.
- **State Management**: If agents are stateful (e.g., `GenServer`s), manage their state carefully. If using shared resources like databases or ETS, handle potential concurrency issues (race conditions, locking).
- **Supervision**: If running multiple agent flows as processes, use OTP Supervisors to ensure fault tolerance and manage the lifecycle of agent processes.
- **Complexity**: Multi-agent systems can become complex quickly. Start simple and clearly define the roles and interactions of each agent.

PocketFlex provides the building blocks (nodes, flows) for agent logic, while Elixir/OTP provides the powerful concurrency and fault-tolerance mechanisms needed to orchestrate multiple agents effectively.

---
# START: Content from pocket_flex/rules_files/docs/tutorials/hello_world.md
---
layout: default
title: "Hello World"
parent: "Tutorials"
nav_order: 1
---

# Tutorial: Hello World

This tutorial demonstrates the most basic PocketFlex flow: two nodes passing a simple message.

## 1. Define Nodes

First, we define two simple nodes.

**Node A: Initiator**

This node starts the flow and puts the initial message into the shared state.

```elixir
# lib/my_hello_app/nodes/initiator_node.ex
defmodule MyHelloApp.Nodes.InitiatorNode do
  # @behaviour PocketFlex.Node
  require Logger

  def prep(_shared_state), do: {:ok, nil} # No input needed from state

  def exec(_prep_data) do
    message = "Hello from InitiatorNode!"
    Logger.info("InitiatorNode: Generating message.")
    {:ok, message}
  end

  def post(shared_state, _prep_data, {:ok, message}) do
    updated_state = Map.put(shared_state, :greeting, message)
    {:ok, {:default, updated_state}}
  end
end
```

**Node B: Receiver**

This node reads the message from the shared state and logs it.

```elixir
# lib/my_hello_app/nodes/receiver_node.ex
defmodule MyHelloApp.Nodes.ReceiverNode do
  # @behaviour PocketFlex.Node
  require Logger

  def prep(shared_state) do
    case Map.fetch(shared_state, :greeting) do
      {:ok, greeting} -> {:ok, greeting}
      :error ->
        Logger.error("ReceiverNode: Greeting not found in state!")
        {:error, :greeting_missing}
    end
  end

  def exec({:ok, greeting}) do
    Logger.info("ReceiverNode: Received message - '#{greeting}'")
    # No modification, just pass the greeting through
    {:ok, greeting}
  end
  def exec({:error, reason}), do: {:error, reason} # Pass prep error through

  def post(shared_state, _prep_data, {:ok, _greeting}) do
    # No state change needed, just signal completion
    {:ok, {:default, shared_state}}
  end
  def post(shared_state, _prep_data, {:error, reason}) do
    Logger.error("ReceiverNode: Failed - #{inspect(reason)}")
    updated_state = Map.put(shared_state, :error_info, {__MODULE__, reason})
    {:ok, {:error, updated_state}} # Use error transition
  end
end
```

## 2. Define Flow

Next, we define the flow connecting these two nodes.

```elixir
# lib/my_hello_app/flow.ex
defmodule MyHelloApp.Flow do
  alias MyHelloApp.Nodes
  # alias PocketFlex # Assuming PocketFlex API

  def define_hello_flow do
    # Hypothetical PocketFlex flow definition
    PocketFlex.define(
      start_node: Nodes.InitiatorNode,
      nodes: [
        %{module: Nodes.InitiatorNode,
          transitions: %{default: Nodes.ReceiverNode}
        },
        %{module: Nodes.ReceiverNode,
          transitions: %{default: :end, error: :end} # End on default or error
        }
      ]
    )
  end
end
```

## 3. Run the Flow

Finally, we create an entry point to run the flow.

```elixir
# lib/my_hello_app.ex (or a script)
defmodule MyHelloApp do
  require Logger
  alias MyHelloApp.Flow
  # alias PocketFlex

  def run_hello_world do
    initial_state = %{} # Start with empty state
    flow_definition = Flow.define_hello_flow()

    Logger.info("Starting Hello World flow...")
    case PocketFlex.run(flow_definition, initial_state) do
      {:ok, final_state} ->
        Logger.info("Hello World flow completed successfully.")
        IO.inspect(final_state, label: "Final State")
      {:error, reason, final_state} ->
        Logger.error("Hello World flow failed: #{inspect(reason)}")
        IO.inspect(final_state, label: "Final State on Error")
    end
  end
end

# To run (example):
# mix run -e "MyHelloApp.run_hello_world()"
```

This simple example illustrates the basic mechanics: defining nodes with `prep`, `exec`, `post`, connecting them in a flow definition, and running the flow with an initial state.

---
# START: Content from pocket_flex/rules_files/docs/tutorials/chatbot.md
---
layout: default
title: "Chatbot"
parent: "Tutorials"
nav_order: 2
---

# Tutorial: Chatbot

This tutorial outlines building a simple conversational chatbot using PocketFlex and an LLM.

## 1. Define Nodes

We need nodes to handle user input, manage conversation history, call the LLM, and present the response.

**Node: GetUserInput**
- `prep`: Maybe gets conversation history from state to show user.
- `exec`: Prompts the user for input (`IO.gets/1`). Returns `{:ok, user_input}`.
- `post`: Adds `user_input` to the shared state under a key like `:current_input` and potentially appends it to a `:history` list. Returns `{:ok, {:default, state}}`.

**Node: PrepareLLMPrompt**
- `prep`: Reads `:current_input` and `:history` from state.
- `exec`: Formats the history and current input into a single prompt string suitable for the LLM (e.g., alternating "User: ...", "Assistant: ..."). Returns `{:ok, llm_prompt}`.
- `post`: Adds `llm_prompt` to the state. Returns `{:ok, {:default, state}}`.

**Node: CallLLM**
- `prep`: Reads `:llm_prompt` from state.
- `exec`: Calls the `MyProject.Utils.LLMCaller.invoke_llm/1` utility (which uses LangchainEx) with the prompt. Returns `{:ok, llm_response_content}` or `{:error, reason}`.
- `post`: If OK, adds `llm_response_content` to state under `:current_response` and appends an assistant message to `:history`. Returns `{:ok, {:default, state}}`. If error, updates state with error info and returns `{:ok, {:error, state}}`.

**Node: DisplayResponse**
- `prep`: Reads `:current_response` from state.
- `exec`: Prints the response to the console (`IO.puts/1`). Returns `{:ok, nil}`.
- `post`: No state change needed. Returns `{:ok, {:default, state}}` to potentially loop back.

**Node: HandleError**
- `prep`: Reads error info from state.
- `exec`: Logs the error, maybe prints a user-friendly error message. Returns `{:ok, nil}`.
- `post`: Clears error info. Returns `{:ok, {:default, state}}` to end or loop.

## 2. Define Flow

The flow connects these nodes, potentially in a loop.

```elixir
# lib/my_chatbot_app/flow.ex
defmodule MyChatbotApp.Flow do
  alias MyChatbotApp.Nodes
  # alias PocketFlex

  def define_chat_flow do
    PocketFlex.define(
      start_node: Nodes.GetUserInput,
      nodes: [
        %{module: Nodes.GetUserInput, transitions: %{default: Nodes.PrepareLLMPrompt}},

        %{module: Nodes.PrepareLLMPrompt, transitions: %{default: Nodes.CallLLM}},

        %{module: Nodes.CallLLM,
          transitions: %{
            default: Nodes.DisplayResponse,
            error: Nodes.HandleError
          }
        },

        %{module: Nodes.DisplayResponse,
          transitions: %{
            default: Nodes.GetUserInput # Loop back for next input
          }
        },

        %{module: Nodes.HandleError,
          transitions: %{
            default: Nodes.GetUserInput # Loop back after error
          }
        }
      ]
    )
  end
end
```

## 3. Run the Flow

```elixir
# lib/my_chatbot_app.ex
defmodule MyChatbotApp do
  require Logger
  alias MyChatbotApp.Flow
  # alias PocketFlex

  def run_chatbot do
    # Initial state includes empty history
    initial_state = %{history: []}
    flow_definition = Flow.define_chat_flow()

    Logger.info("Starting Chatbot flow...")
    # Run the flow (PocketFlex.run might block or run async depending on implementation)
    # For a chatbot, you might run this within a GenServer or loop manually.
    # This example assumes PocketFlex.run handles the looping based on transitions.
    case PocketFlex.run(flow_definition, initial_state) do
      # Depending on how PocketFlex handles infinite loops or end states,
      # the return here might indicate completion or an unhandled exit.
      {:ok, final_state} ->
        Logger.info("Chatbot flow finished (unexpectedly?).")
        IO.inspect(final_state, label: "Final State")
      {:error, reason, final_state} ->
        Logger.error("Chatbot flow failed: #{inspect(reason)}")
        IO.inspect(final_state, label: "Final State on Error")
    end
  end
end

# To run:
# mix run -e "MyChatbotApp.run_chatbot()"
```

## Enhancements

- **Memory Management**: Limit the size of the `:history` list passed to the LLM to manage context window size and cost.
- **Streaming Responses**: Modify `CallLLM` and `DisplayResponse` to use the streaming capabilities of the LLM (if supported by the LangchainEx model/utility) for a better user experience.
- **Error Recovery**: Improve error handling logic.
- **State Persistence**: Save/load conversation history from a database.

---
# START: Content from pocket_flex/rules_files/docs/tutorials/code_generation.md
---
layout: default
title: "Code Generation"
parent: "Tutorials"
nav_order: 3
---

# Tutorial: Code Generation

This tutorial shows how PocketFlex can be used with an LLM to generate code based on a specification.

## 1. Define Nodes

**Node: GetSpecification**
- `prep`: None.
- `exec`: Reads the code specification (e.g., from a file specified in initial state, or prompts user).
- `post`: Adds the specification string to the shared state under `:spec`.

**Node: GenerateCode**
- `prep`: Reads `:spec` from state.
- `exec`: Constructs a detailed prompt for the LLM asking it to generate Elixir code based on the `:spec`. Calls the `LLMCaller.invoke_llm/1` utility.
- `post`: Adds the generated code string (extracted from the LLM response) to state under `:generated_code`. Handles LLM errors.

**Node: ValidateCode (Optional but Recommended)**
- `prep`: Reads `:generated_code` from state.
- `exec`: Attempts to parse or validate the code.
    - Simple validation: Check for basic syntax errors (e.g., using `Code.string_to_quoted/1`).
    - Advanced validation: Write the code to a temporary file and try to compile it (`mix compile`), or run basic tests against it.
- `post`: Adds validation status (`:ok` or `:error`) and any error messages to state under `:validation_result`. Determines transition (`:valid` or `:invalid`).

**Node: SaveCode**
- `prep`: Reads `:generated_code` and maybe a target filename from state.
- `exec`: Writes the code to the target file (`File.write/2`).
- `post`: Updates state indicating success/failure.

**Node: HandleGenerationError**
- `prep`: Reads error info (from `GenerateCode` or `ValidateCode`).
- `exec`: Logs the error, notifies the user.
- `post`: Clears error state.

## 2. Define Flow

```elixir
# lib/my_codegen_app/flow.ex
defmodule MyCodegenApp.Flow do
  alias MyCodegenApp.Nodes
  # alias PocketFlex

  def define_codegen_flow do
    PocketFlex.define(
      start_node: Nodes.GetSpecification,
      nodes: [
        %{module: Nodes.GetSpecification, transitions: %{default: Nodes.GenerateCode}},

        %{module: Nodes.GenerateCode,
          transitions: %{default: Nodes.ValidateCode, error: Nodes.HandleGenerationError}
        },

        %{module: Nodes.ValidateCode,
          transitions: %{
            valid: Nodes.SaveCode,
            invalid: Nodes.HandleGenerationError, # Or loop back to GenerateCode?
            error: Nodes.HandleGenerationError # Error during validation itself
           }
        },

        %{module: Nodes.SaveCode,
          transitions: %{default: :end, error: Nodes.HandleGenerationError}
        },

        %{module: Nodes.HandleGenerationError,
          transitions: %{default: :end}
        }
      ]
    )
  end
end
```

## 3. Run the Flow

```elixir
# lib/my_codegen_app.ex
defmodule MyCodegenApp do
  require Logger
  alias MyCodegenApp.Flow
  # alias PocketFlex

  def run_codegen(spec_file, output_file) do
    initial_state = %{spec_file: spec_file, output_file: output_file}
    flow_definition = Flow.define_codegen_flow()

    Logger.info("Starting Code Generation flow...")
    case PocketFlex.run(flow_definition, initial_state) do
      {:ok, final_state} ->
        Logger.info("Code Generation flow completed.")
        # Check final_state for success/failure indicators
        IO.inspect(final_state, label: "Final State")
      {:error, reason, final_state} ->
        Logger.error("Code Generation flow failed: #{inspect(reason)}")
        IO.inspect(final_state, label: "Final State on Error")
    end
  end
end

# To run:
# mix run -e 'MyCodegenApp.run_codegen("path/to/spec.md", "path/to/output.ex")'
```

## Key Considerations

- **Prompt Quality**: The success heavily depends on the prompt given to the LLM in `GenerateCode`. It should be specific, provide context, and clearly state the desired output format (e.g., "Generate only the Elixir code module. Do not include explanations.").
- **Validation**: Simple syntax checking is often insufficient. Trying to compile or run tests against the generated code provides much higher confidence.
- **Error Handling/Retries**: If validation fails, the flow could loop back to `GenerateCode` with modified instructions (e.g., including the previous error) to attempt self-correction.

---
# START: Content from pocket_flex/rules_files/docs/tutorials/web_search.md
---
layout: default
title: "Web Search Integration"
parent: "Tutorials"
nav_order: 4
---

# Tutorial: Web Search Integration

This tutorial demonstrates integrating an external tool, like a web search API, into a PocketFlex flow.

## 1. Define Utility

First, create a utility module to handle the web search API call. (We use a simplified example here; a real implementation would use `Req` and handle authentication/errors more robustly).

```elixir
# lib/my_search_app/utils/search_client.ex
defmodule MySearchApp.Utils.SearchClient do
  @moduledoc """Handles calls to an external web search API."""
  require Logger

  @api_key System.get_env("SEARCH_PROVIDER_API_KEY")
  @endpoint "https://api.searchprovider.com/search"

  @spec search(String.t(), keyword()) :: {:ok, list(map())} | {:error, any()}
  def search(query, opts \\ []) do
    num_results = Keyword.get(opts, :num_results, 3)
    Logger.info("Searching web for '#{query}' (max #{num_results} results)...")

    # In a real scenario, use Req to make the HTTP call:
    # headers = [authorization: "Bearer #{@api_key}"]
    # params = [q: query, count: num_results]
    # case Req.get(@endpoint, headers: headers, params: params) do
    #   {:ok, %{status: 200, body: %{"results" => results}}} -> {:ok, results}
    #   ... error handling ...
    # end

    # Placeholder for example:
    {:ok, [
      %{title: "Result 1 for #{query}", snippet: "Snippet 1...", url: "http://example.com/1"},
      %{title: "Result 2 for #{query}", snippet: "Snippet 2...", url: "http://example.com/2"},
      %{title: "Result 3 for #{query}", snippet: "Snippet 3...", url: "http://example.com/3"}
    ] |> Enum.take(num_results)}
  end
end
```

## 2. Define Nodes

**Node: GetSearchQuery**
- `prep`: None.
- `exec`: Prompts user for a search query.
- `post`: Adds query to state as `:search_query`.

**Node: PerformSearch**
- `prep`: Reads `:search_query` from state.
- `exec`: Calls `MySearchApp.Utils.SearchClient.search/2` with the query. Returns `{:ok, results_list}` or `{:error, reason}`.
- `post`: Adds results to state as `:search_results`. Handles errors.

**Node: SummarizeResults (Optional LLM Step)**
- `prep`: Reads `:search_query` and `:search_results`.
- `exec`: Formats the search results into a context string. Creates a prompt asking an LLM to summarize the results for the original query. Calls `LLMCaller.invoke_llm/1`.
- `post`: Adds summary to state as `:search_summary`. Handles LLM errors.

**Node: DisplayResults**
- `prep`: Reads `:search_results` and optionally `:search_summary`.
- `exec`: Prints the results (and summary, if available) nicely formatted.
- `post`: Signals completion.

**Node: HandleSearchError**
- Standard error handling node.

## 3. Define Flow

```elixir
# lib/my_search_app/flow.ex
defmodule MySearchApp.Flow do
  alias MySearchApp.Nodes
  # alias PocketFlex

  def define_search_flow do
    PocketFlex.define(
      start_node: Nodes.GetSearchQuery,
      nodes: [
        %{module: Nodes.GetSearchQuery, transitions: %{default: Nodes.PerformSearch}},

        %{module: Nodes.PerformSearch,
          transitions: %{
            default: Nodes.SummarizeResults, # Go to summarize
            error: Nodes.HandleSearchError
          }
        },

        %{module: Nodes.SummarizeResults,
          transitions: %{
            default: Nodes.DisplayResults,
            error: Nodes.DisplayResults # If LLM fails, still display raw results
          }
        },

        %{module: Nodes.DisplayResults, transitions: %{default: :end}},

        %{module: Nodes.HandleSearchError, transitions: %{default: :end}}
      ]
    )
  end
end
```

## 4. Run the Flow

```elixir
# lib/my_search_app.ex
defmodule MySearchApp do
  require Logger
  alias MySearchApp.Flow
  # alias PocketFlex

  def run_search do
    initial_state = %{}
    flow_definition = Flow.define_search_flow()

    Logger.info("Starting Web Search flow...")
    case PocketFlex.run(flow_definition, initial_state) do
      {:ok, final_state} ->
        Logger.info("Web Search flow completed.")
        IO.inspect(final_state, label: "Final State")
      {:error, reason, final_state} ->
        Logger.error("Web Search flow failed: #{inspect(reason)}")
        IO.inspect(final_state, label: "Final State on Error")
    end
  end
end

# To run:
# mix run -e "MySearchApp.run_search()"
```

This tutorial shows how external tools are wrapped in utility modules and invoked by dedicated PocketFlex nodes within a larger flow.

---
# START: Content from pocket_flex/rules_files/examples/llm_caller.ex
---
# lib/my_project/utils/llm_caller.ex
defmodule MyProject.Utils.LLMCaller do
  @moduledoc """
  Provides a utility function to interact with an LLM using LangchainEx chains.
  This approach offers more flexibility for adding system prompts, memory, etc.
  """
  require Logger
  alias LangChain.Chains.LLMChain
  alias LangChain.LLM.OpenAI # Or your chosen provider
  alias LangChain.Message

  # Consider making the LLM and Chain configuration dynamic or configurable
  # For the example, we define a default one.
  defp default_llm(config \\ %{model: "gpt-4o"}) do
    # Assumes API key is in environment (e.g., OPENAI_API_KEY)
    OpenAI.new(config)
  end

  defp default_chain(llm) do
    # Basic chain, could add system prompts, memory, etc. here
    LLMChain.new!(%{llm: llm})
    # Example with system prompt:
    # |> LLMChain.add_message(Message.new_system!("You are a helpful assistant."))
  end

  @doc """
  Invokes the configured LLM Chain with a single user prompt.

  Handles basic invocation. For streaming or more complex interactions
  (like adding conversation history), create more specific functions.

  Returns `{:ok, response_content}` or `{:error, reason}`.
  """
  @spec invoke_llm(String.t(), map() | LangChain.LLM.t(), LLMChain.t() | nil) :: {:ok, String.t()} | {:error, any()}
  def invoke_llm(user_prompt, llm \\ nil, chain \\ nil) do
    llm = llm || default_llm()
    chain = chain || default_chain(llm)

    # Convert the simple prompt string into a Langchain User Message
    user_message = Message.new_user!(user_prompt)

    Logger.debug("Running LLM Chain with message: #{inspect(user_message)}")

    # Add the user message to the chain for this run
    # Note: Depending on chain type/memory, adding might modify state persistently
    # or just for this run. Basic LLMChain is stateless for messages added this way.
    chain_with_message = LLMChain.add_message(chain, user_message)

    case LLMChain.run(chain_with_message) do
      {:ok, _final_chain_state, response} ->
        # Response structure depends on the LLM/ChatModel used
        # We assume a structure containing a `content` field
        content = Map.get(response, :content, inspect(response))
        Logger.info("LLM Chain run successful.")
        Logger.debug("LLM Response content: #{content}")
        {:ok, content}
      {:error, reason} ->
        Logger.error("LLM Chain run failed: #{inspect(reason)}")
        {:error, reason}
      other ->
        # Catch unexpected return values from run/1
        Logger.error("LLM Chain run returned unexpected value: #{inspect(other)}")
        {:error, {:unexpected_chain_result, other}}
    end
  end

  # Example of how you might add a streaming function later
  # @spec stream_llm(pid(), String.t(), map(), LLMChain.t() | nil) :: any()
  # def stream_llm(receiver_pid, user_prompt, llm_config \\ %{}, chain \\ nil) do
  #   llm = default_llm(Map.put(llm_config, :stream, true)) # Ensure streaming is enabled
  #   chain = chain || default_chain(llm)
  #   user_message = Message.new_user!(user_prompt)
  #
  #   handler = %{ # Define callback handlers for streaming }
  #
  #   chain
  #   |> LLMChain.add_callback(handler)
  #   |> LLMChain.add_llm_callback(handler) # If needed for the model
  #   |> LLMChain.add_message(user_message)
  #   |> LLMChain.run() # Run likely triggers the async stream
  # end
end

---
# START: Content from pocket_flex/rules_files/examples/flow_definition.ex
---
# lib/my_project/flow.ex
defmodule MyProject.Flow do
  # Assume Nodes are defined elsewhere
  # alias MyProject.Nodes
  # Assume PocketFlex API is available
  # alias PocketFlex

  def define_rag_flow do
    # Hypothetical PocketFlex flow definition
    # Replace with actual PocketFlex API calls
    # PocketFlex.define(
    #   start_node: Nodes.GetQueryNode,
    #   nodes: [
    #     %{module: Nodes.GetQueryNode, transitions: %{default: Nodes.FormatNode}},
    #     %{module: Nodes.FormatNode, transitions: %{default: Nodes.RetrieveNode, error: :end_flow_error}},
    #     %{module: Nodes.RetrieveNode, transitions: %{default: Nodes.SynthesizeNode, error: :end_flow_error}},
    #     %{module: Nodes.SynthesizeNode, transitions: %{default: :end_flow_success, error: :end_flow_error}}
    #   ]
    # )

    # Placeholder return for the example file
    {:ok, :flow_definition_placeholder}
  end
end

---
# START: Content from pocket_flex/rules_files/examples/synthesize_node.ex
---
# lib/my_project/nodes/synthesize_node.ex
defmodule MyProject.Nodes.SynthesizeNode do
  @moduledoc "Node that uses the LLM to synthesize an answer."
  # @behaviour PocketFlex.Node # Assuming this behaviour
  require Logger
  # Assuming the utility is aliased or imported elsewhere
  # alias MyProject.Utils.LLMCaller

  def prep(shared_state) do
    query = Map.get(shared_state, :user_query)
    docs = Map.get(shared_state, :retrieved_docs, [])
    {:ok, %{query: query, docs: docs}}
  end

  def exec({:ok, %{query: query, docs: docs}})
      when is_binary(query) and is_list(docs) do
    context = Enum.map_join(docs, "\n\n", fn doc -> doc.content end) # Adjust based on actual doc structure
    prompt = """
    Based on the following context:
    --- Context ---
    #{context}
    --- End Context ---

    Answer the question: #{query}
    """

    Logger.debug("Executing SynthesizeNode with prompt length: #{String.length(prompt)}")
    # Call the utility that uses LangchainEx
    # Replace with actual call, e.g.: MyProject.Utils.LLMCaller.invoke_llm(prompt)
    # For this example file, we'll return placeholder data
    {:ok, "This is a synthesized answer based on the context."}
  end
  def exec({:ok, prep_data}) do
     Logger.error("SynthesizeNode: Invalid prep data received: #{inspect(prep_data)}")
     {:error, :invalid_prep_data}
  end
  def exec({:error, reason}) do
     {:error, reason} # Propagate prep error
  end

  def post(shared_state, _prep_data, {:ok, llm_response}) do
    Logger.info("SynthesizeNode successful.")
    new_state = Map.put(shared_state, :llm_response, llm_response)
    {:ok, {:default, new_state}}
  end
  def post(shared_state, _prep_data, {:error, reason}) do
     Logger.error("SynthesizeNode failed during exec: #{inspect(reason)}")
     new_state = Map.put(shared_state, :error_info, {__MODULE__, reason})
     {:ok, {:error, new_state}} # Transition to error state/path
  end
end

---
# START: Content from pocket_flex/rules_files/examples/initial_state.ex
---
# Example initial state definition
initial_state = %{
  user_query: nil,
  retrieved_docs: [],
  llm_response: nil,
  error_info: nil
}

# You might access it like this (example):
# IO.inspect(initial_state.user_query)

---
# START: Content from pocket_flex/rules_files/examples/web_search.ex
---
# lib/my_project/utils/web_search.ex
defmodule MyProject.Utils.WebSearch do
  @moduledoc """Utility for performing web searches."""
  require Logger

  @search_api_key System.get_env("SEARCH_API_KEY")
  @search_endpoint "https://api.example-search.com/search"

  @spec search(String.t()) :: {:ok, list(map())} | {:error, any()}
  def search(query) do
    Logger.info("Performing web search for: #{query}")
    # Use Req to call a search API
    case Req.get(@search_endpoint, params: [q: query], headers: [authorization: "Bearer #{@search_api_key}"]) do
      {:ok, %{status: 200, body: %{"results" => results}}} ->
         Logger.debug("Search successful. Found #{length(results)} results.")
        {:ok, results}
      {:ok, resp} ->
        Logger.error("Web search failed with status #{resp.status}: #{inspect(resp.body)}")
        {:error, {:unexpected_response, resp.status}}
      {:error, reason} ->
        Logger.error("Web search HTTP request failed: #{inspect(reason)}")
        {:error, reason}
    end
  end
end
