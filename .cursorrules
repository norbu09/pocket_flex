# PocketFlex Project Rules

## Build and Test
- Use mix as the build system
- Run tests with mix test
- Always ensure code compiles without warnings
- Create tests as part of generated code
- Run mix compile at the end of each step to verify no new errors
- Use ExUnit's setup blocks for common test setup
- Prefer property-based testing with StreamData for complex data structures
- Use mox for mocking external dependencies in tests

## Documentation
- Documentation can be found at hexdocs.pm
- Use the hex_docs package for documentation
- Use doc tests where possible
- URL syntax for docs is [https://hexdocs.pm/{package}/](https://hexdocs.pm/{package}/)
- Add @moduledoc and @doc to all modules and public functions
- Include examples in documentation for complex functions
- Document all public functions with clear parameter and return value descriptions

## Code Style and Structure
- Format code with mix format
- Put defp functions at the bottom of modules and public def functions at the top
- Create smaller files rather than one huge file (cut off at around 300 lines)
- Run mix credo to check if anything needs refactoring
- Use pattern matching in function heads instead of conditionals when possible
- Prefer pipe operator |> for multi-step transformations
- Use with statements for clean sequential operations that may fail
- Prefer function capture (&) syntax for simple anonymous functions
- Use guards to clarify function head conditions
- Avoid deep nesting of conditionals

## Error Handling
- Always prefer ok/error tuples (the Erlang way) to try/catch blocks
- Use atoms for control flow, never strings
- Use ErrorHandler module for standardized error reporting
- Implement proper error recovery mechanisms
- Provide meaningful error messages with context
- Use :error_logger for system-level errors
- Handle all possible error cases explicitly
- Propagate errors up the call stack with consistent formatting
- Use rescue only for exceptional circumstances, not for control flow
- Include stacktraces with errors in development environments

## Dependencies
- Libraries in mix.exs should always be added with ">=" and never pinned to specific versions
- Always use the latest versions of libraries
- Use req for writing new APIs
- Regularly update dependencies to get security patches
- Minimize dependency count to reduce complexity
- Prefer standard library solutions when available
- Document why each dependency is needed in mix.exs

## Concurrency and Performance
- Use Task for concurrent operations that don't need to communicate
- Prefer GenServer for stateful concurrent processes
- Use Registry for dynamic process registration
- Avoid global process names in favor of local registration
- Consider ETS tables for shared state that needs fast access
- Use Supervisor trees for fault tolerance
- Implement proper shutdown handling for all processes
- Use Task.async_stream for parallel processing with controlled concurrency

## Logging and Debugging
- For logging and debugging always use Logger, never IO.inspect
- Remember to require Logger when you use it
- Ensure comprehensive error tracking and logging
- Use appropriate log levels (debug, info, warning, error)
- Include context in log messages (flow_id, node, etc.)
- Configure logger backends appropriately for each environment
- Use structured logging for machine-parseable logs
- Add metadata to logs for better filtering and searching

## Architecture
- Never add Mix to any code that runs in production (breaks in production)
- When refactoring, maintain existing data structures without modifications
- Keep AsyncBatchFlow and AsyncParallelBatchFlow in separate files
- Follow Erlang-style error handling with {:ok, result} and {:error, reason} tuples
- Use atoms for flow actions (e.g., :default, :success, :error) not strings
- Follow the single responsibility principle for modules
- Design for testability with dependency injection
- Use behaviours and protocols for polymorphism
- Separate business logic from infrastructure concerns
- Use contexts to group related functionality
- Implement proper boundary modules to isolate system components

## Security
- Never store sensitive information in code or version control
- Use environment variables for configuration
- Validate all external inputs
- Implement proper authentication and authorization
- Use secure communication channels (HTTPS, TLS)
- Follow the principle of least privilege
- Regularly update dependencies for security patches
- Audit code for security vulnerabilities
- Hash passwords with strong algorithms (Argon2, Bcrypt)
- Implement proper rate limiting for APIs

## References and Inspiration
- The original inspiration for PocketFlex came from the Python library "PocketFlow" (https://github.com/The-Pocket/PocketFlow)
- When implementing new features, consider checking the Python implementation for architectural patterns
- While adapting patterns from Python, ensure they follow Elixir/Erlang idioms and best practices
- Key differences to note when comparing to Python version:
  * Immutable data structures in Elixir vs mutable in Python
  * Process-based concurrency in Elixir vs threading in Python
  * Pattern matching in Elixir vs conditional logic in Python
  * Functional approach in Elixir vs object-oriented in Python 